#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;

layout(location = 0) rayPayloadEXT hitPayload prd;

const float PHI = 1.6180339887498948482;

const vec2 SAMPLES_4[4] = vec2[](
    vec2(-0.25, -0.25),
    vec2( 0.25, -0.25),
    vec2(-0.25,  0.25),
    vec2( 0.25,  0.25)
);

const vec2 SAMPLES_8[8] = vec2[](
    vec2( 0.125,  0.375),
    vec2( 0.625,  0.125),
    vec2( 0.375,  0.875),
    vec2( 0.875,  0.625),
    vec2( 0.3125, 0.1875),
    vec2( 0.8125, 0.4375),
    vec2( 0.5625, 0.9375),
    vec2( 0.0625, 0.6875)
);

vec2 rotatedSample(vec2 s, float r) {
    s = fract(s + vec2(r, r));
    return s - 0.5; // center to [-0.5, 0.5]
}

void main() 
{
    const uvec2 gid = uvec2(gl_LaunchIDEXT.xy);
    const vec2  res = vec2(gl_LaunchSizeEXT.xy);

    const mat4 invView = inverse(sceneData.view);
    const mat4 invProj = inverse(sceneData.proj);

    int mode = int(sceneData.data.z);
    int sampleCount = 1;
    if (mode == 2) sampleCount = 4;
    else if (mode == 3) sampleCount = 8;

    float frame = sceneData.data.x;
    float rot = fract(frame * (PHI - 1.0));

    vec3 accum = vec3(0.0);

    for (int i = 0; i < sampleCount; ++i)
    {
        vec2 jitter = vec2(0.0);
        if (sampleCount == 4)  jitter = rotatedSample(SAMPLES_4[i], rot);
        if (sampleCount == 8)  jitter = rotatedSample(SAMPLES_8[i], rot);

        vec2 pixel = vec2(gid) + jitter;
        vec2 uv = pixel / res;
        vec2 ndc = uv * 2.0 - 1.0;

        vec4 o = invView * vec4(0, 0, 0, 1);
        vec4 t = invProj * vec4(ndc.x, ndc.y, 1, 1);
        vec4 d = invView * vec4(normalize(t.xyz), 0);

        prd.recursionDepth = 0;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0, 0, 0,
            o.xyz, 0.001,
            d.xyz, 10000.0,
            0
        );

        accum += prd.hitValue;
    }

    accum *= 1.0 / float(sampleCount);
    imageStore(image, ivec2(gid), vec4(accum, 1.0));
}
